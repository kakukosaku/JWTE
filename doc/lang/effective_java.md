# Effective Java

- 创建和销毁对象

1. 用静态工厂代替构造器
2. 遇到多个构造器参数时使用使用构建器(builder)
3. 用私有构造器或者枚举类型强化Single属性
4. 通过私有构造器强化不可实例化的能力
5. 优先考虑依赖注入来引用资源
6. 避免创建不必要的对象
7. 消除过期的对象引用
8. 避免使用终结方法`finalize`和清除方法`clear`
9. try-with-resources优先于try-finally

- 对于所有对象都通用的方法

10. 覆盖equals时请遵守通用约定
11. 覆盖equals时总要覆盖hashCode
12. 始终要覆盖toString
13. 谨慎覆盖clone
14. 考虑实现Comparable接口

- 类和接口

15. 使类和成员的可访问性最小化
16. 要在仅有类而非公有域中使用访问方法
17. 使可变性最小化
18. 复合优先于继承
19. 要么设计继承并提供文档说明, 要么禁止继承
20. 接口优于抽象类
21. 为后代设计接口
22. 接口只用于定义类型
23. 类层次优于标签类
24. 静态成员类优于非静态成员类
25. 限制源文件为单个顶级类

- 泛型

26. 请不要使用原生类型
27. 消除非受检的警告
28. 列表优于数组
29. 优先考虑泛型
30. 优先考虑泛型方法
31. 利用有限制通配符来提升API的灵活性
32. 谨慎并用泛型和可变参数
33. 优先考虑类型安全的异构容器

- 枚举和注解

34. 用enum代替int常量
35. 用实例域代替序数`this.ordinal()`
36. 用EnumSet代替位域(bit field)
37. 用EnumMap代替序数索引
38. 用接口模拟可拓展的枚举
39. 注解优先于命名模式
40. 坚持使用`Override`注解
41. 用标记接口定义类型

- Lambda 和 Stream

42. Lambda优先于匿名类
43. 方法引用优先于Lambda
44. 坚持使用标准的函数接口
45. 谨慎使用Stream
46. 优先选择Stream中无副作用的函数
47. Stream要优先用Collection作为返回类型
48. 谨慎使用Stream并行
